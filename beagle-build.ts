import { Type } from '@angular/core'
import { relative, dirname, basename } from 'path'
import { writeFileSync, existsSync, mkdirSync } from 'fs'
import 'reflect-metadata'
// @ts-ignore
import aotConfig from './beagle.aot.json'

const defaultComponentModuleName = 'ComponentModule'
const defaultConfigName = 'config'

function kebabToCamelCase(str: string) {
  return str.replace(/-\w/g, ([_, letter]) => letter.toUpperCase())
}

function removeExtraIndentation(code:string, numberOfExtraSpaces: number) {
  return code
    .replace(new RegExp(`\\n\\s{${numberOfExtraSpaces}}`, 'g'), '\n')
    .replace(/^\n/, '')
    .replace(/\s*$/, '')
}

function getComponentAnnotations(component: Type<any>) {
  return Reflect.get(component, '__annotations__')[0]
}

function getComponentInputs(component: Type<any>) {
  const props = Reflect.get(component, '__prop__metadata__') || {}
  const propNames = Object.keys(props)
  return propNames.filter((name) => {
    const decoratorPrototype: any = Reflect.getPrototypeOf(props[name][0])
    return decoratorPrototype.ngMetadataName === 'Input'
  })
}

function createTemplateForComponent(selector: string, inputs: string[]) {
  const templateName = kebabToCamelCase(selector)
  const templateInputs = inputs.map(input => `let-${input}="${input}"`).join(' ')
  const componentInputs = inputs.map(input => `[${input}]="${input}"`).join(' ')
  return `
    <ng-template #${templateName} ${templateInputs} let-children="children">
      <${selector} ${componentInputs}>
        <ng-container *ngFor="let child of children">
          <ng-container *ngTemplateOutlet="getTemplate(child.type);context:child"></ng-container>
        </ng-container>
      </${selector}>
    </ng-template>
  `
}

function createCommentaryString() {
  const commentary = `
    /***
     * BEAGLE-ANGULAR
     *
     * Please, do not change this file.
     *
     * This file has been automatically generated by the lib beagle-angular. This is necessary when
     * the developer doesn\'t want to use the JIT angular compiler. With this, you should be able
     * to use the beagle-angular library without ever loading the JIT. The module created here
     * should be imported by the modules where you need to use the component "beagle-remote-view".
     *
     * This file should be regenerated every time a component in your beagle configuration is added,
     * removed or its inputs are changed. To regenerate it, run:
     * yarn beagle-build-aot
     **/
  `

  return removeExtraIndentation(commentary, 4)
}

function createImportsString(
  configPath: string,
  componentModulePath: string,
  configName?: string,
  componentModuleName?: string,
) {
  const configImport = configName
    ? `import { ${configName} } from '${configPath}'`
    : `import ${defaultConfigName} from '${configPath}'`

  const componentModuleImport = componentModuleName
    ? `import { ${componentModuleName} } from '${componentModulePath}'`
    : `import ${defaultComponentModuleName} from '${componentModulePath}'`

  const importString = `
    import {
      Component,
      NgModule,
      ViewChild,
      NgZone,
      ChangeDetectorRef,
      Injectable,
    } from '@angular/core'
    import { CommonModule } from '@angular/common'
    import { AbstractBeagleRemoteView, AbstractBeagleProvider } from 'beagle-angular'
    ${configImport}
    ${componentModuleImport}
  `

  return removeExtraIndentation(importString, 4)
}

function createProviderString() {
  const providerString = `
    @Injectable()
    export class BeagleProvider extends AbstractBeagleProvider {}
  `

  return removeExtraIndentation(providerString, 4)
}

function createTemplateString(components: Type<any>[]) {
  const componentTemplates = components.map((componentType: any) => {
    const selector = getComponentAnnotations(componentType).selector
    const inputs = getComponentInputs(componentType)
    return createTemplateForComponent(selector, inputs)
  })

  const container = `
    <ng-container #__view_container>
      <ng-container *ngIf="!!tree">
        <ng-container *ngTemplateOutlet="getTemplate(tree.type);context:tree">
        </ng-container>
      </ng-container>
    </ng-container>
  `

  const ngTemplates = removeExtraIndentation(componentTemplates.join(''), 2)
  const ngContainer = removeExtraIndentation(container, 2)

  return `const template = \`\n${ngTemplates}\n${ngContainer}\n\``
}

function createQueries(components: Record<string, Type<any>>) {
  const componentNames = Object.keys(components)

  return componentNames.map((name) => {
    const selector = getComponentAnnotations(components[name]).selector
    const templateName = kebabToCamelCase(selector)
    return `${name}: new ViewChild('${templateName}', { static: true })`
  })
}

function createComponentString(components: Record<string, Type<any>>) {
  const queries = createQueries(components)

  const componentString = `
    @Component({
      selector: 'beagle-remote-view',
      template,
      inputs: ['loadParams'],
      queries: {
        ${queries.join(',\n        ')},
      },
    })
    export class BeagleRemoteView extends AbstractBeagleRemoteView {
      constructor(
        beagleProvider: BeagleProvider,
        ngZone: NgZone,
        changeDetector: ChangeDetectorRef,
      ) {
        // @ts-ignore
        super(beagleProvider, ngZone, changeDetector)
      }
    }
  `

  return removeExtraIndentation(componentString, 4)
}

function createModuleString(componentModuleName = defaultComponentModuleName) {
  const moduleString = `
    @NgModule({
      declarations: [BeagleRemoteView],
      exports: [BeagleRemoteView],
      imports: [CommonModule, ${componentModuleName}],
      providers: [BeagleProvider],
    })
    export class BeagleModule {
      constructor(provider: BeagleProvider) {
        provider.start(config)
      }
    }
  `

  return removeExtraIndentation(moduleString, 4)
}

function getDirPathPrefix(dir: string) {
  if (!dir) return '.'
  if (dir.startsWith('.')) return ''
  return './'
}

function getImportFilePath(from: string, to: string) {
  const fromDir = dirname(from)
  const toDir = dirname(to)
  const toFile = basename(to, '.ts')
  const relativeDir = relative(fromDir, toDir)
  const prefix = getDirPathPrefix(relativeDir)

  return `${prefix}${relativeDir}/${toFile}`
}

function getComponents(configPath: string, configName = 'default') {
  const config = require(configPath)[configName]
  return config.components as Record<string, Type<any>>
}

function ensureDirectoryExistence(filePath: string) {
  const directory = dirname(filePath)
  if (existsSync(directory)) return true
  ensureDirectoryExistence(directory)
  mkdirSync(directory)
}

function start() {
  const components = getComponents(aotConfig.configPath, aotConfig.configName)
  const commentary = createCommentaryString()
  const importString = createImportsString(
    getImportFilePath(aotConfig.outputPath, aotConfig.configPath),
    getImportFilePath(aotConfig.outputPath, aotConfig.componentModulePath),
    aotConfig.configName,
    aotConfig.componentModuleName,
  )
  const templateString = createTemplateString(Object.values(components))
  const componentString = createComponentString(components)
  const providerString = createProviderString()
  const moduleString = createModuleString(aotConfig.componentModuleName)
  const fileContent = `${commentary}\n\n${importString}\n\n${templateString}\n\n${componentString}\n\n${providerString}\n\n${moduleString}\n`

  ensureDirectoryExistence(aotConfig.outputPath)
  writeFileSync(aotConfig.outputPath, fileContent)
  console.log(`Beagle module for AOT compilation has been successfully generated at "${aotConfig.outputPath}"! Don't forget to manage your imports.`)
}

start()
